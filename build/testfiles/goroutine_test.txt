package Testmain

import (
	//"os"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/consensus"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/eth/downloader"
	"github.com/ethereum/go-ethereum/eth/fetcher"
	"github.com/ethereum/go-ethereum/ethdb"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/log"
	"github.com/ethereum/go-ethereum/p2p"
	"github.com/ethereum/go-ethereum/p2p/discover"
	"github.com/ethereum/go-ethereum/params"
	"os"
	"sync"
	"testing"
)
type protocolManager struct {
	networkId uint64

	fastSync  uint32 // Flag whether fast sync is enabled (gets disabled if we already have blocks)
	acceptTxs uint32 // Flag whether we're considered synchronised (enables transaction processing)

	//txpool      txPool
	blockchain  *core.BlockChain
	chaindb     ethdb.Database
	chainconfig *params.ChainConfig
	maxPeers    int

	downloader *downloader.Downloader
	fetcher    *fetcher.Fetcher
	//peers      *peerSet

	SubProtocols []p2p.Protocol

	eventMux      *event.TypeMux
	txSub         *event.TypeMuxSubscription
	minedBlockSub *event.TypeMuxSubscription

	// channels for fetcher, syncer, txsyncLoop
	//newPeerCh   chan *peer
	//txsyncCh    chan *txsync
	quitSync    chan struct{}
	noMorePeers chan struct{}

	// wait group is used for graceful shutdowns during downloading
	// and processing
	wg sync.WaitGroup
}
type istanbulProtocolManager struct {
	*protocolManager

	engine   consensus.Istanbul
	eventSub *event.TypeMuxSubscription
}
func adder(a int, b int, res_chan chan int) {
	c := a + b
	res_chan <- c
}


func newIstanbulProtocolManager(config *params.ChainConfig, mode downloader.SyncMode, networkId uint64, maxPeers int, mux *event.TypeMux, txpool txPool, engine consensus.Istanbul, blockchain *core.BlockChain, chaindb ethdb.Database) (*istanbulProtocolManager, error) {
	// Create eth63 protocol manager
	//defaultManager, err := newProtocolManager(config, mode, networkId, maxPeers, mux, txpool, engine, blockchain, chaindb)
	if err != nil {
		return nil, err
	}

	// Create the istanbul protocol manager
	manager := &istanbulProtocolManager{
		protocolManager: defaultManager,
		engine:          engine,
	}

	// Support only Istanbul protocol
	manager.SubProtocols = []p2p.Protocol{
		p2p.Protocol{
			Name:    istanbulName,
			Version: istanbulVersion,
			Length:  istanbulProtocolLength,
			Run: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {
				peer := manager.newPeer(int(istanbulVersion), p, rw)
				select {
				case manager.newPeerCh <- peer:
					manager.wg.Add(1)
					defer manager.wg.Done()
					return manager.handle(peer, manager.handleMsg)
				case <-manager.quitSync:
					return p2p.DiscQuitting
				}
			},
			NodeInfo: func() interface{} {
				return manager.NodeInfo()
			},
			PeerInfo: func(id discover.NodeID) interface{} {
				if p := manager.peers.Peer(fmt.Sprintf("%x", id[:8])); p != nil {
					return p.Info()
				}
				return nil
			},
		},
	}

	return manager, nil
}

func (pm *istanbulProtocolManager) Start() {
	// Subscribe required events
	pm.eventSub = pm.eventMux.Subscribe(istanbul.ConsensusDataEvent{}, core.ChainHeadEvent{})
	go pm.eventLoop()
	pm.protocolManager.Start()
	pm.engine.Start(pm.protocolManager.blockchain, pm.commitBlock)
}

func (pm *istanbulProtocolManager) Stop() {
	log.Info("Stopping Ethereum protocol")
	pm.engine.Stop()
	pm.protocolManager.Stop()
	pm.eventSub.Unsubscribe() // quits eventLoop
}

// handleMsg handles Istanbul related consensus messages or
// fallback to default procotol manager's handler
func (pm *istanbulProtocolManager) handleMsg(p *peer, msg p2p.Msg) error {
	// Handle Istanbul messages
	switch {
	case msg.Code == IstanbulMsg:
		pubKey, err := p.ID().Pubkey()
		if err != nil {
			return err
		}
		var data []byte
		if err := msg.Decode(&data); err != nil {
			return errResp(ErrDecode, "msg %v: %v", msg, err)
		}
		return pm.engine.HandleMsg(pubKey, data)
	default:
		// Invoke default protocol manager's message handler
		return pm.protocolManager.handleMsg(p, msg)
	}
}

// event loop for Istanbul
func (pm *istanbulProtocolManager) eventLoop() {
	for obj := range pm.eventSub.Chan() {
		switch ev := obj.Data.(type) {
		case istanbul.ConsensusDataEvent:
			pm.sendEvent(ev)
		case core.ChainHeadEvent:
			pm.newHead(ev)
		}
	}
}

// sendEvent sends a p2p message with given data to a peer
func (pm *istanbulProtocolManager) sendEvent(event istanbul.ConsensusDataEvent) {
	// FIXME: it's inefficient because it retrieves all peers every time
	p := pm.findPeer(event.Target)
	if p == nil {
		log.Warn("Failed to find peer by address:istanbul_handler.go", "addr", event.Target)
		return
	}
	p2p.Send(p.rw, IstanbulMsg, event.Data)
}

func (pm *istanbulProtocolManager) commitBlock(block *types.Block) error {
	if _, err := pm.blockchain.InsertChain(types.Blocks{block}); err != nil {
		log.Debug("Failed to insert block", "number", block.Number(), "hash", block.Hash(), "err", err)
		return err
	}
	// Only announce the block, don't broadcast it
	go pm.BroadcastBlock(block, false)
	return nil
}

func (pm *istanbulProtocolManager) newHead(event core.ChainHeadEvent) {
	block := event.Block
	if block != nil {
		pm.engine.NewChainHead(block)
	}
}

// findPeer retrieves a peer by given address
func (pm *istanbulProtocolManager) findPeer(addr common.Address) *peer {
	for _, p := range pm.peers.Peers() {
		log.Debug("findPeer", p)
		pubKey, err := p.ID().Pubkey()
		if err != nil {
			continue
		}
		if crypto.PubkeyToAddress(*pubKey) == addr {
			return p
		}
	}
	return nil
}


func TestMain(t *testing.T){
	ret := t.Run()

	chan1 := make(chan int)
	chan2 := make(chan int)

	go adder(0, 1, chan1)
	go adder(0, 2, chan2)

	res1 := <-chan1
	res2 := <-chan2

	fmt.Printf("Channel 1: %d\nChannel 2: %d\n", res1, res2)
	os.Exit(ret)
}